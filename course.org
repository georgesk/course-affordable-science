#+TITLE:       Affordable Measurement Box for Science
#+AUTHOR:      Georges Khaznadar
#+DATE:        <2016-07-19 Tue>
#+EMAIL:       <georges.khaznadar@free.fr>
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:t toc:t
#+LATEX_HEADER: \usepackage{lmodern}

* Booting live USB sticks
** We proudly choose an "Unsecure" system

Some laptop manufacturers are applying a new policy proposed by Microsoft:
disallow users to boot freely their operating systems, verify that the system
loaded during the boot process bears a cryptographic signature approved by
Microsoft. This feature is known as "Secure Boot", as presumabily operating
systems can be considered as secure, only if they are made by Microsoft company.

So far, Microsoft company does not provide free/libre operating systems, and
as we want to distribute live USB sticks which our students will be able to
duplicate, understand, and even enhance, Microsoft Windows cannot be used.
To have a more precise idea about the problem, let us take a look at the
end-user agreement which comes with Windows 10:

 (excerpt of
 https://www.microsoft.com/en-us/Useterms/OEM/Windows/10/UseTerms_OEM_Windows_10_English.htm)
 1. [...]
 2.      Installation and Use Rights.
  a.      License. The software is licensed, not sold.[...]
  b. [...]
  c.      Restrictions. [...] this license does not give you any right to, and you may not:
    (i)      use or virtualize features of the software separately;
    (ii)     publish, copy (other than the permitted backup copy), rent, lease, or lend the software;
    [...]
    (vi)    reverse engineer, decompile, or disassemble the software, or attempt to do so [...]

*** To sum it up:
- the software is licensed, not sold: /it can be free as *free beer*, but as
 we shall see further, it is not free as in *freedom*./
- students (and teachers) are not allowed to publish, neither to distribute
 copies of the operating system. Even if this may be technically feasible, one can be sued if she does it.
- students (and teachers) will never be allowed to understand how the
 operating system works. Its source is not published, and attempts to
 reverse engineer its binaries are forbidden by license.

*** So to sum up the summary:

|--------------------------------------------------|
| <c>                                              |
| AS WE WANT OUR STUDENTS TO BE ABLE TO UNDERSTAND |
| WHAT THEY USE AND WHAT THEY DO,                  |
| WE MUST DEFINITELY OPT FOR UNSECURE SYSTEMS.     |
|--------------------------------------------------|

** Disabling the "Secure Boot" feature

Until year 2015, vendors who wanted to apply the "Approved by Microsoft"
sticker on their laptop had to enforce the "Secure Boot" feature by default,
but they used to let a possibility for the users to disable this feature,
more or less easily.

More recently, vendors who want to get this sticker are encouraged to remove
the possibility of disabling the "Secure Boot" feature. Depending on anti-trust
law which apply in such or such country, this removal can be considered legal
or not. However, one can now find laptops which are difficult to boot without
the "Secure Boot" feature.

Here are hints provided by Microsoft Company, about disabling the "Secure Boot"
feature (source: https://msdn.microsoft.com/en-us/windows/hardware/commercialize/manufacture/desktop/disabling-secure-boot)

*** To disable Secure Boot:

    Before disabling Secure Boot, consider whether it is necessary. From time to time, your manufacturer may update the list of trusted hardware, drivers, and operating systems for your PC. To check for updates, go to Windows Update, or check your manufacturer's website.

    Open the PC BIOS menu. You can often access this menu by pressing a key during the bootup sequence, such as F1, F2, F12, or Esc.

    Or, from Windows, hold the Shift key while selecting Restart. Go to Troubleshoot > Advanced Options: UEFI Firmware Settings.

    Find the Secure Boot setting, and if possible, set it to Disabled. This option is usually in either the Security tab, the Boot tab, or the Authentication tab.

    Save changes and exit. The PC reboots.

    Install the graphics card, hardware, or operating system that’s not compatible with Secure Boot.

    In some cases, you may need to change other settings in the firmware, such as enabling a Compatibility Support Module (CSM) to support legacy BIOS operating systems. To use a CSM, you may also need to reformat the hard drive using the Master Boot Record (MBR) format, and then reinstall Windows. For more info, see Windows Setup: Installing using the MBR or GPT partition style.

    If you’re using Windows 8.1, you may see a watermark on the desktop alerting
    you that Secure Boot is not configured correctly. Get this update to remove
    the Secure Boot desktop watermark.

** Now our system is ready, let's boot with the USB stick

When possible, alongside with the "Secure Boot" option tweak, you can choose the
order of bootable devices. If the live USB stick is plugged in, you may reorder
boot methods so the USB stick is considered as prioritary (before the boot on
hard disk, and before the boot on network interface). If you could define the
USB stick as a prioritary boot medium, just keep it plugged in while booting.

If you could not define the default boot sequence order, you can choose the boot
medium on the fly: on most laptops, the key "F8" (or F9, or F12) is dedicated at
this purpose. If the key is activated during the early boot process, you are
given the choice between a few boot options in the so-called "boot menu". Choose
your USB stick, and press "Enter".

When the system can boot from the USB stick, and if the graphic card of the
laptop is VESA compatible, you will see a welcome splash screen provided by GRUB
(GRand UNified Bootloader), with a few options selectable by keyboard's arrow
keys. Usually, you just need to wait a few seconds, or you can type "Enter" to
select the first entry. Then the boot process begins, and you can see a few
messages on the screen, during the hardware check-up. One minute later, the
graphic desktop should be usable.

The main menu (applications, settings, etc.) lies in the left bottom corner, you
can begin exploring it. When an Ethernet cable is plugged in, the automatic
configuration of network access is attempted, and chances are that you begin
with a usable network configuration. There is also a possibility to get network
access thanks to WIFI hotspots if any.

 # this is a comment
* Why should I use a live USB stick with free software?
** Ten reasons why live USB sticks are /good/:
The following set of reasons is non-exhaustive!
1. I can get an efficient system with a USB stick weighing 8GB. This is
 quite affordable. About one half of the storage space is used for the
 operating system and programs; the second half is available for the "payload";
2. When I am travelling, or just going from place to place, all I need can
 fit in my pocket;
3. As far as I want to keep my USB stick /private/, I know that no spy program
 hosted by the local computer will access my data;
4. Duplicating a USB stick (and all of its features) is a matter of a quarter
 of an hour;
5. With the KNOPPIX-based live system, I can also duplicate the operating
  system and the programs without disclosing private data;
6. When used in an educational context, USB live sticks provide an interesting
 feature: students can replay an exercise, or finish it outside the classroom,
 with exactly the same software environment they were using previously;
7. A live USB stick can be used to boot a computer when it cannot boot
 on its hard disk for any reason; it is a valuable rescue system;
8. A live USB stick can survive in a washing machine; a computer cannot;
9. A live USB stick can survive strong accelerations, like falling downstairs; a
 computer cannot;
10. *Small is beautiful (see figure [[fig:usb-stick]]).*

#+CAPTION: Don't keep more in your pocket
#+NAME:   fig:usb-stick
[[./img/usb-stick.jpg]]

** Ten reasons why free software and open formats will be preferred:
1. Free software is defined by a list of four elementary freedoms,
   a. the freedom to use the software in any case (for example, not only in
    educational context);
   b. the freedom to learn how the software functions. That implies an access to
    its source code;
   c. the freedom to make derivative works based on the software;
   d. the freedom to copy and distribute the software, either in its original
    form or as a derivative work;
2. As, with the definition above, there is no limitation of use (the software
   does not need to be shared costlessly), people can earn their life when
   working with free software;
3. As the source of the software must be delivered with it, fair interactions
   can be organized between competitors; every company can access specifications
   about open formats being used; however, competitors cannot build their wealth
   upon secrecy; the cost of the software must be justified by its quality;
4. As the source of the software must be transmitted along, the software becomes
   "eternal", in the sense that you can always hire a skilled person to adapt
   the software and maintain it if a previous author or vendor fails to do it;
5. Free software can be audited for security issues by specialists, who can know
   details of its design by studying its source; if a security issue is
   detected, it can be fixed by the same people;
6. When the source of the software is written in a "human readable" form, one
   can check that there is no spyware included;
7. When the software is used to make science (or to teach science), it is not
   a "black box"; everyone may watch its internals, and experiments can be
   readily reproduced;
8. When there is no constraint on copies or instances of a running software,
   license management is way cheaper;
9. The ability for everyone to access the source of the software is a strong
   incentive for progress and software quality;
10. Most non-free software from the last ten years is now dead; on the contrary,
    free software, even when it is old, can be revived with some work; the same
    is true with data which were saved in non-open formats, if nobody took the
    opportunity to convert them to a new format when it was still possible.
** Why would my students like to use copies of my live USB stick?
Here are a few "irrational reasons" why my students like my system based on
a live USB stick:
- Thanks to [[https://en.wikipedia.org/wiki/Klaus_Knopper][Klaus Knopper]]'s efforts, every derivative of KNOPPIX comes with an
  excellent support of accelerated graphic cards, and the desktop is managed by
  Compiz. If you do not know what Compiz provides, you cannot understand why
  your students are playing with dozens of applications open in separate
  windows, like jugglers with their balls.
- Creating awesome graphics is a matter of seconds; open Gimp, then
  File \rightarrow Create \rightarrow Logos \rightarrow (choose a style) \rightarrow (type your logos's text)  \rightarrow click,
  /et voilà/!
- They can cheat when preparing their homework! For example, the application
  wxMaxima allows them to find immediately the roots of most equations. Of
  course, when students "begin to cheat", the teacher just needs to propose them
  more creative assignments: they become able to solve problems which are
  usually thought as out of their reach at their education level.
And now, here here is at least one "rational reason" why my students do use my
system based on a live USB stick:
- They are assigned homework which can precisely be done with the help of
  that live USB stick.
* First use of the expEYES box
** Pickup voltage: where does it come from?
#+CAPTION: Main window of expEYES-Jr features an oscilloscope screen
#+NAME:   fig:expeyes00
[[./img/expeyes-jr00.png]]

Boot your computer with the live USB stick; bind the expEYES Jr box to the
computer with a USB cable, launch the application expEYES Junior (probably
a menu item under Education \rightarrow Science). The window which appears should bear
a mention to the detected hardware in its title bar, and feature an oscilloscope
screen with one track enabled. In figure [[fig:expeyes00]], one can read "Four
Channel CRO+ found expEYES-Junior on =/dev/ttyACM0=", which means that the
application "CRO+" (an enhanced Cathode-Ray Oscilloscope) has detected the box
named expEYES-Junior, via the serial port known as =/dev/ttyACM0=.

Take an insulated wired in your hand (do not touch directly the metal), and
touch the analogic input A1 with the bare end of the wire. The track on the
oscilloscope screen should change a little. Then change the duration of the
sampled data set, by dragging the slider "ms/div" to the right (this slider is
on the left of the window, just below the list of channels CH1 ... CH4). When
the duration of the sweep is well tuned, you shall see a few wave periods in the
oscilloscope's screen.

#+CAPTION: Pickup voltage, time sweep: 5 ms/div
#+NAME:   fig:expeyes01
[[./img/expeyes-jr01.png]]

Click the "Save Traces to" button: a file named =cro.txt= (or some other name if you
change the default) will be written. You can take a look at this file, with
various tools. Try to open the file with the following applications:
1. inside a Terminal, type the command =cat cro.txt= (and type "Enter"): you will
   be provided many lines of text, which you can scroll up and down with the
   vertical slider of the terminal. The command =cat= is a very simple command: it
   opens one or more files given as arguments, and concatenates their contents
   to the standard output, which is the terminal's display in that case.
2. inside the same terminal, type the command =less cro.txt= (and type "Enter"):
   you will be provided the same set of lines, but you are using a so-called
   "pager" (the command =less= calls the default pager of the system). You can
   access previous and following lines by using vertical arrow keys, or Page-Up
   Page-Down keys. Type "Q" to stop the pager program and come back to the
   terminal's prompt.
3. launch the application Qtiplot (probably available under the menu Education
   \rightarrow Science). Then, import data from the file =cro.txt=: Window's Menu \rightarrow File \rightarrow
   Import \rightarrow import an ASCII file, or quicker with the graphic button which does
   the same (an icon with "123" written above), or else with the keyboard
   shortcut Ctrl+K. Chose the right file, import it. If numbers are not well
   imported, you may want to change some import options, like the number's input
   format. The values from the file =cro.txt= will be displaied in a data
   grid. You can select both columns with the mouse, then plot the data easily
   (either by calling a contextual menu by a right click, or by using the
   "Plot" window's menu). The application Qtiplot has many features to analyze
   data series, which deserve a detailed study.
4. you can also import the data with LibreOffice's spreadsheet program, known as
   =calc=. When data are there, other features of the spreadsheet can be enjoied.

#+CAPTION: The same data, accessed by "cat", "less" and "qtiplot"
#+NAME:   fig:cat-less-qtiplot
[[./img/cat-less-qtiplot.png]]

While maintaining the right sampling settings, use the left mouse button
to drag the symbol "CH1" to the symbol "FIT" in the left part of the screen. The
application will begin to fit the sampled data with a template function based on
a sinus. The amplitude and the frequency should appear in "real time" near the
oscilloscope's screen.

In order to reply to the title's question, while maintaining the wire connected
to the A1 input, one hand on the insulating part of the wire, move your body, or
just a member, nearer or further from areas where you know that power lines are
embedded. If the "FIT" feature is enabled, you may notice that the amplitude
depends tightly on the proximity between your body and power lines, while the
frequency remains mostly unchanged. One can read "A1: 0.19 V, 50.8 Hz"
in the middle of the right part of the window, in figure [[fig:expeyes01]].

Another question which is worth a short
documentation search for students is "why precisely 50 Hz?". Wikipedia's web
site gives valuable information about the history of that frequency standard.
** experimenting with a few wires only
ExpEYES-Junior is a measurement box, but not only that: it is enhanced by
numerous generators. By the way, the program =expeyes-junior= comes with some
powerful features, like one-click Fourier transform.
*** Fourier transform, page 30 of the manual
As a first try, let us open the /User Manual/, page 30.
It is a simple manipulation about Fourier transforms, for a sinusoidal and for
a square wave.

The manual says to use two wires, one from SINE to A1, the second from SQR1 to
A2. I rather use four short wires with crocodile clips, and do the same by
joining clips accordingly.

When the box is bound to the computer, and the wires are in place, please launch
the program expeyes-junior. Figure [[fig:exp-wave00]] shows two oscilloscope
tracks, we can see that SQR1 is enabled, with a frequency of 150 Hz.

The symbols A1 and A2 in the left column of the window have been dragged with
the mouse and dropped on the symbols CH1 and CH2 respectively.

#+CAPTION: Two tracks of the oscilloscope are used, the frequency of both signals are quite the same
#+NAME:   fig:exp-wave00
[[./img/exp-wave00.png]]

In order to get a Fourier transform of the signals, the manipulation is very
simple: when you drag the symbol CH1 on the neighboring symbol FTR, you get
a new window with figure [[fig:exp-wave01]], and when you drag CH2 on FTR, you get
another window with figure [[fig:exp-wave02]]. The fast Fourier transform is done
quickly by the application. You can notice more peaks in the FFT plot of the
square wave. The first peak is a frequency 0 (it is due to a non-null DC
component), and other peaks are at frequencies which build an arithmetic progression.

#+CAPTION: Fourier transform of the SINE wave
#+NAME:   fig:exp-wave01
[[./img/exp-wave01.png]]
#+CAPTION: Fourier transform of SQR1's signal at 150 Hz
#+NAME:   fig:exp-wave02
[[./img/exp-wave02.png]]
*** Using the MIC output
Install a wire (or two wires bound by crocodile clips) between the MIC socket,
which is the outpout of an amplified microphone, and A1, the first analog input.
Then, you must provide some "musical" sound near the microphone, which is placed
at the left bottom end of the expEYES box. For example, use some whistle, or
sing a single tune during a few seconds. Adjust the time sweep in order to have
a few waves in the oscilloscope's display. Begin to drag the symbol CH1 above
the symbol FTR, and drop it when the oscilloscope's track is well shaped. This
records data in two files: =cro.dat=, which contains original data resampled with
a time step which ensures that a good FFT can be done, and =fft.dat=, which is the
fast fourier transform of the same data to give a power /vs./ frequecy spectrum.

The figures [[fig:exp-wave03]] to [[fig:exp-wave06]] show data recorded,first with
a voiced "AAA", then with a mouth-wistled still tune of higher frequency.

#+CAPTION: A voiced "AAA": the original signal
#+NAME:   fig:exp-wave03
[[./img/exp-wave03.png]]
#+CAPTION: A voiced "AAA": fast fourier transform
#+NAME:   fig:exp-wave04
[[./img/exp-wave04.png]]

#+CAPTION: Mouth-whistled still tune: the original signal
#+NAME:   fig:exp-wave05
[[./img/exp-wave05.png]]
#+CAPTION: Mouth-whistled still tune: fast fourier transform
#+NAME:   fig:exp-wave06
[[./img/exp-wave06.png]]

Further is (figure [[fig:exp-wave07]]) another analysis of a mouth-whistled tune, done
with the file =cro.dat= which was imported (as ASCII data) in the application
=qtiplot=. You can notice that the abscissa for frequency should be kHz (not Hz),
because the unit for time exported from =expeyes-junior= is millisecond, not
second.

#+CAPTION: Another mouth-whistled still tune, analyzed by qtiplot.
#+NAME:   fig:exp-wave07
[[./img/exp-wave07.png]]

*** A "standalone" experiment, with the DC motor
:PROPERTIES:
:ID:       fef7fc86-e6a0-4170-ae48-dad0ffc2e80e
:END:
The expEYES-Junior kit comes with a DC motor (which is ordinarily used to drive
a CDROM); this DC motor can act as a low voltage motor, but it is also an
efficient tachymeter, that is, an angular velocity probe: it outputs a voltage
which is proportional to its angular velocity, and as it has few internal
friction, it can be used to measure the movement of a pendulum. When the main
application =expeyes-junior= is running, click on the "EXPERIMENTS" button:
a submenu appears, where you must activate the entry named "Pendulum Waveform".

The window of the main application remains in place, but it looses the control
of the experiment box, which is given to a specialized application. To enjoy the
secondary application, you must make the following connections:

1. from inverting amplifier's OUT plug to analog entry A1, with one wire;
2. the motor's wires are connected between the ground (GND), and the input (IN)
   of the inverting amplifier.

Then, you can check that the second application begins to record voltage data as
soon as the motor has enough angular velocity.You can stop the record at any
time with the "STOP" button.

Put the motor's axis horizontal, near the edge of a table, and grasp firmly the
motor's body. Fit the motors's axis to a pendulum; there are many ways to do it,
all are correct, as long as most of the mass ofthe pendulum is far enough from
the motor's axis, and that the pendulum remains tightly fixed to the motor's
axis during oscillations.

Here are two easy and cheap solutions used by the author:
- either a metal pendulum coupled to the motor's axis with a small and strong
  enough magnet,
- or a wood stick fastened to the motor's axis with a screw for wood of diameter
  2 mm, with some relatively heavy clip fastened at the other end of the stick,
  see figure [[fig:pendulum01]].

When the motor is int good position, slowly put the pendulum far fromits
equilibrium position, and let it go freely. The angular velocity probed by the
motor goes quicly above the threshold which triggers the record's begin. The
record's duration is 15 seconds by default (but you can change it). When the
record is finished, you should click on two buttons, first "SAVE To", later
"FIT". So, you get a file with the data recorded, for further analysis, and the
FIT method gives you two interesting coefficients: the oscillation's
pseudo-frequency, and its damping coefficient; see figure [[fig:pendulum00]].

The last figure of this section ([[fig:pendulum02]]) shows the data from the file
=pendulum.dat= reworked with =qtiplot='s analysis tools (Analysis \rightarrow Fit Wizard
... define a user fit). You can see that the choosen formula is
$A1 * \exp(-x/A2) * \sin(2 * \pi * A3 * x + A4)$; so, it is a damped sinusoidal
function, with damping coefficient $A2$, frequency $A3$, and phase $A4$; $A1$ is an
arbitrary multiplying factor. Initial values to perform the fit were $A1=1.5$
(the order of magnitude of the initial amplitude), $A2=10$, as the movement is
significantly damped within 10 seconds, $A3=1$ since the pseudo-frequency is
near $1\, Hz$, and $A4=1.5$ (which is near $\pi/2$). The fitting algorithm of =qtiplot=
yelds a damping factor $A2=1.2\, s$ and a frequency $A3=1.069\, Hz$, with an
excellent correlation factor: $R^2=0.993$. The precision is greater for the
frequency than for the damping factor.

#+CAPTION: Record of a pendulum's angular velocity
#+NAME:   fig:pendulum00
[[./img/pendulum00.png]]
#+CAPTION: Pendulum made with a wood stick, a screw and a clip.
#+NAME:   fig:pendulum01
[[./img/pendulum01.png]]
#+CAPTION: Reworking the data with qtiplot.
#+NAME:   fig:pendulum02
[[./img/pendulum02.png]]
* Mastering Python
Python is an interpreted computer language created by by Guido van Rossum at
Centrum Wiskunde & Informatica (CWI) in the Netherlands, fifteen years ago
approximately. Currently thislanguage is considered as excellent for dealing
with scientific and experimental data, and most important software libraries
which can be used it that area have been llinked to Python and areexposing
well-documented Programming Interfaces.

** Empowering oneself with Python
Archimedes said "/Give me a place to stand and with a lever I will move the whole
world/". He was probably thinking about Python ;).

Computers come now with unprecedented arithmetic power, and there are clever
programs which make it usable for calculus also. Of course, students must know
how to make operations by themselves, but when thousands of calculations are
necessary, controlling a computer is the solution. Python is one of the shortest
ways to control this power.

Incidentally,  the way Python programs must be written makes them often quite
readable by non-aware people. I could discuss with a teacher of philosophy who
showed me a source program and pointed one precise part, saying "there is an
error, right there!".
** A guide to learn Python quickly
*** Level of difficulty
Learning to walk with one's legs is a non-trivial task, most humans achieve it
in their early youth. Driving a helicopter is also a non-trivial task, but few
humans achieve it, even if it might give them huge advantages. There are reasons
why few persons can learn to drive a helicopter: the learning environment is
very expensive, and also somewhat risky: a beginner can destroy a helicopter and
herself in the same run with some probability.

Learning arithmetic operations is also a tough task, which most persons achieve
in developed countries. Controlling a computer, compared to basic arithmetics,
is quite like driving a helicopter, compared to walking. However, unlike the
helicopter example, it is much safer: Python is a free-libre program, you can
get it gratuitously; accidentally breaking a computer while learning
computer science with Python is most unlikely.

In a few words, the best guide to learn Python quickly is your own curiosity,
as long as you choose a project which makes sense. Good tutorials exist in many
places, here is the tutorial of the Python Fundation:
https://docs.python.org/3/tutorial/index.html.

Currently, there are two families in the Python language, known as Python2 and
Python3; the fork between both families has begun a few years ago. If you
are beginning, you should definitely learn Python3, as it is the only branch
which will be maintained and developed in the future, even if many efforts are
still deployed to help the large community of people who are still using Python2.

*** Examples of small projects which can be used to learn Python
1. Repeat writing the same line of text many times
2. Write lines of text made of some character, for example a star (*), which
   will build some interesting shape when watched from some distance: a ball,
   a robot, a toy, a pet, etc.
3. Produce automatically arithmetic tables: for addition, multiplication,
   etc. and why not, logarithms too?
4. Create some interactive game: the computer asks a question, the player
   replies, the further exchanges depend on the replies, etc. For instance, the
   computer chooses a random number within a range, and the player has a limited
   number of questions left to know which it is ...
5. Draw an elephant, which will cross the screen, coming from the left and going
   to the right (or the opposite)
6. Create a structure which can be used to manage your collection of music
   records, and two different routines to display collection's items, with more
   or less details
7. Create an interactive program which allows one to query your collection's
   items, based on search criteria (author, some words from the title, music style,
   etc.)
8. Write a program which quickly solves equations of degree one, two ... three,
   four (if you dare to go that far)
9. Write a program able to say how many different colors there are in a picture
10. Write a program which automatically detects a human face in a given picture

Propositions of solutions for this set of exercises are published in the
"[[https://github.com/georgesk/course-affordable-science/tree/master/sol/generic][repository]]".
*** Python and expEYES
Your computer does not work in "real time": that means that when you begin some
task, you cannot require with certitude a precise duration for that task to
complete. For example, if you want your computer to measure a thousand times the
voltage of a precise pin during one second, you cannot be sure that it will
perform this operation uninterrupted.

This is why the physical measurements are done inside expEYES box with
a separate program designed to work in /real time/. Then, your computer can ask
the box to make the thousand measurements, they will be done
uninterrupted. Later, the results will be given back to your computer, possibly
with some interruptions, but you are sure that the data were captured on
a regular time basis. As the computer, despite its many interruptions, works
very very fast, you experience a rich feedback, not unlike the feeling you can
have with an oscilloscope. However, because of its calculation capability,
your computer can go way further than an oscilloscope, and this is why Python is
used, to enjoy the many libraries which can crunch numbers for us.

Now, let us begin with Python+expEYES: let us open the application =geany= (a
good development environment for programmers... Windows users will probably use
=Notepad++=), and type the few lines presented in figure [[fig:ej01]]. Then, save them
with the filename =p1.py=. As soon as the name of the file is defined, =geany= will use
colors and styles to make the syntax of the source file more evident. For
example, key words like =import=, =print=, are displaid in a particular fashion.

#+CAPTION: Our first program with Python+expEYES ever.
#+NAME:   fig:ej01
[[./img/ej01.png]]

When the file is saved, press the "F5" key (it is a shortcut to launch
the program which has been edited). You will get a heap of numbers written in
a /Terminal/, and you will be prompted to press the "Enter" key. When you press
it, the /Terminal/ is closed. The series of numbers were a sequence of voltages
measured very fast on the analog input A1. If you want more variety inside this
sequence of numbers, you can connect a wire to this input and act exactly as for
the previous experiment [[Pickup voltage: where does it come from?]["Pickup voltage"]]. The number sequence can be impressive,
but it not as expressive as a good plot. In order to make a plot, you need three
more lines in the program. Save the previous program with a new file name, like
=p2.py=. So, the first program still exists and can be used as a begin point for
other variations. Then add three more lines, as showed in figure
[[fig:ej02]]. Save the program and type "F5". If there is some "pickup voltage", you
should get a plot like in figure [[fig:ej03]].

#+CAPTION: The second program with Python+expEYES.
#+NAME:   fig:ej02
[[./img/ej02.png]]
#+CAPTION: The plot given by the second program
#+NAME:   fig:ej03
[[./img/ej03.png]]

You can notice that the plot comes in a separate window which has its own close
button, and that you will have to close the /Terminal/ too after the end of the
program.

*** Understanding the first programs for Python+expEYES
Let us comment the few lines in the program =p1.py=:
- =import expeyes.eyesj= :: this declares that the library which drives
     expEYES-Junior will be used; the library's name is expeyes.eyesj, if we
     want a shorter alias, it is possible to declare it, more about that later ...
- p=expeyes.eyesj.open() :: this line calls the function =open()= from the library
     which drives expEYES-Junior, and the resulting object is stored into the
     /variable/ =p=; hence, =p= contains the intialized driver to deal with the
     measurement box.
- t, v=p.capture(1,100,2000) :: this line calls the method =capture()= from the
     driver, with three parameters:
  1. =1= is the number of the input channel; =1= stands for channel A1
  2. =100= is the number of samples to collect: a hundred of measurements are
     requested
  3. =2000= is the duration between two consecutive measurements: measurements
     will be done every $2000\, ns = 2\, \mu s$; so the total duration of the
     "experiment" is requested to be $200\, \mu s$. The results are assigned to
     /variables/ =t= and =v=, =t= is the list of timestamps, =v= is the liste of measured
     voltages.
- =print(v)= :: this line asks to print the hundred values measured in the
     /standard output/ of the program, which is the /Terminal/, there.

Now let us comment the new lines in the program =p2.py=:
- =import expeyes.eyesj as ej= :: exactly the same as in =p1.py=, but the alias =ej=
     will be used to name the library.
- =from pylab import *= :: this line means that every objects and functions of the
     library =pylab= will be available directly in the program. Such an
     instruction may cause problems if two libraries provide same names for
     different functions. Here there will be no problem because the program is
     very short. The functions which will be used are =plot()= and =show()=.
- p=ej.open() :: exactly the same as in =p1.py=, you can notice that the alias =ej=
     is used there.
- plot(t,v) :: this is the call to a function provided by the library =pylab=, it
     builds a very simple plot with the series of values =t= as abscissa and the
     series of values =v= as ordinate.
- =show()= :: this call creates a graphic window to contain the plot, and allow
     users to interact with it. This window "lives" independently of the main
     program.
*** Proposition of exercises
as you can see, the plot in figure [[fig:ej02]] is not very precise, and some
features of the expected waveform are not as detailed as they might be. You can
make a series of exercises, in order to:
- make more measurements, in the same total time
- make a longer measurement, with more samples but same laps of time
You can also try to find the limits of the measurement box:
- which is the shortest duration between two consecutive measurements?
- how many measurements can be stored in the box for a one-shot measurement
  series?
- how many different inputs has the box, which numbers are they assigned?
- etc.

Propositions of solutions for this set of exercises are published in the
"[[https://github.com/georgesk/course-affordable-science/tree/master/sol/basics][repository]]".
** Python libraries for science
As we already know, Python exists for fifteen years approximately, and most
important free and open-sourcelibraries have been made available for Python,
thanks to a versatile toolset which allows one to link C and C++ libraries to
Python language.

You can access a good review about Python Libraries for Science at
https://wiki.python.org/moin/NumericAndScientific. Here are the two first
entries of this webpage, as captured in August 2016:
- NumPy :: http://www.numpy.org/ -- Numerical Python adds a fast, compact,
     multidimensional array facility to Python. [...]
- SciPy :: http://www.scipy.org/ SciPy is an open source library of scientific
     tools for Python. SciPy supplements the popular NumPy module, gathering
     a variety of high level science and engineering modules together as
     a single package. SciPy includes modules for linear algebra, optimization,
     integration, special functions, signal and image processing, statistics,
     genetic algorithms, ODE solvers, and others.
*** =numpy=: the advantage of using arrays vs. plain Python lists
When one uses plain Python, she can manipulate series of numbers as so-called
lists: for example the 10 first even integers are this Python list:
=[0,2,4,6,8,10,12,14,16,18]=; such a list can have a memory footprint bigger than
ten times the place necessary to store an integer, because Python lists can
contain any type of element (for example, a list can contain another list), and
such a flexibility requires more memory space and sometimes slower algorithms to
take in account all the possibilities.

The module numpy allows you to declare or to construct numeric arrays, which
contain only numbers, and which can be computed efficiently. The figure [[fig:np0]]
shows the code to get the same numbers as above in an array.
#+CAPTION: ten first even numbers, with numpy: source code, and ouput
#+NAME: fig:np0
[[./img/np0.png]]
The =arange= function allows us to build very easily long arithmetic
series. For example =arange(0,2,1e-3)= yelds an array of two thousand numbers.

Numpy provides also mathematic functions and operators which work directly on
arrays; here are two example programs, in figures [[fig:np1]] and [[fig:np2]].

Both compute =y=2*x= and =z=sin(x)= for any element of an arithmetic series, we can
notice that =numpy= allows us to use a more clear programming style!

#+CAPTION: some math with number series, without numpy
#+NAME: fig:np1
[[./img/np1.png]]

#+CAPTION: some math with number series, and numpy
#+NAME: fig:np2
[[./img/np2.png]]

** Python libraries for graphic user interfaces
Some Python modules used for science can provide good tools for user
interaction: for example, the module =pylab= provides two functions, =plot()= and
=show()= which are very handy to get a simple plot in an interactive window: users
can zoom in some part of the plot, and save it in a file, etc.
*** General purpose GUI libraries
However user interfaces must often contain some controls to let the user trigger
a physic interaction, or to launch some process on captured data. So, general
purpose GUI (Graphic User Interface) modules are useful. A good GUI library
allows one to internationalize easily a program, making it usable by wide
communities. Additionnally, good GUI libraries inherit knowledge about
human-machine interaction, and the author of programs can focus her attention
about things which really matter for the end user: creating an /intuitive
interface/, /i.e./ reusing popular widgets with well-known behaviors, defining
contextual help phrases, making the current status well understandable, etc.

One good practice is to develop separately the user interface's layout and the
program's processes which do the "backoffice work".
*** GUI design programs
Some popular GUI libraries come with a specialized application to design the GUI
layout. For Gnome Toolkit libraries (Gtk), it is known as [[https://glade.gnome.org/][=glade=]]; we shall
make some exercises below with [[http://doc.qt.io/qt-5/qtdesigner-manual.html][=designer=]], which goes with Qt. Both =Gtk= and =Qt=
libraries work well with Python, and they can target a wide list of platforms,
ranging from desktop and laptop computers with various operating systems, to
mobile devices.

*** Our first GUI layout
Let us create our first GUI layout with =designer=, which will feature:
1. one area to plot scientific data
2. one button to launch a specific process
3. one button to quit the application.

To begin with, the appplication =designer= must be launched without any option. So
it will display a menu and we shall choose the =Main Window= item. An empty Main
Window prototype appears in the center of the screen, collections of widgets are
proposed in a column at the left side.

Scroll down this column, select the widget known as =QwtPlot= which is part of the
"Qwt widgets" family, and drag its icon to the top of the Main Window prototype.

Then scroll up the widget column, select a =Horizontal layout= widget, and drag it
onto the Main Window, drop it below the =QwtPlot= footprint. Then, you must drag
and drop two =Push Button= widgets onto the =Horizontal Layout=. The first one is
easily dropped. In order to get a usable structure, the second one must be
dropped when a dark blue line appears on the west or on the east border of the
=Horizontal Layout=, meaning that the second button will be organized horizontally
either on the right or on the left of the previous button. If you want the
buttons to be packed on the right, you can drag and drop a =Horizontal Spacer=
widget at the east border of the =Horizontal layout=. Then, click on some free
area of the Main Window to select it, and click on the "Vertical Layout" _tool
button_, in the upper part of the window, just below the menus. This will
organize all of the Main Window.

Finally, save your work (File \rightarrow Save) with some filename like =p1.ui=

It is better to add more attributes to the push buttons. Click on the left push
button to select it, then browse its attributes in the middle of the right
column of =designer='s window. There, you should modify the button's name to
"measureButton" (QObject \rightarrow objectName) and its label to "Measure"
(QAbstractButton \rightarrow text). Select the right push button, and make similar
modifications: its name should be "closeButton" and its label should be "Close".

Save you work again. It is finished, you can close the application =designer=.

The suffix =.ui= of the saved file means that this a file to describe the layout
of the GUI in an open format. More than an application is able to read and to
interpret this format efficiently and to compose a sensible user interface.

*** Compiling the layout file to a Python program
1. Open a Terminal, ensure that the default directory contains the recently made
   =p1.ui= file, type the command line =pyuic4 p1.ui -o UI_p1.py=, and hit the Enter
   key. This will create a new file in Python language with the name
   =UI_p1.py=.
2. Open that last file with a source editor, go to the end, and make
   a small change to the last line: instead of =from qwt_plot import QwtPlot=,
   this line should contain: =from qwt import QwtPlot=, to comply with the name of
   the module inside a Debian distribution (I assume that we are working with
   the USB live stick). This second operation should not be necessary, it is
   just implied by a small bug in the debian package of =pyuic4=, the convertor
   from =designer='s =.ui= format to Python source.

*** Our first working program
Here is our first program which will rely upon the just created user
interface. The series of snapshots (taken from =geany='s buffers) has a few
comments.

#+CAPTION: Program's header with inclusion of modules and definition of our custom Main Window
#+NAME:   fig:firstgui00
[[./img/firstgui00.png]]

#+CAPTION: The constructor of our custom window: mandatory part
#+NAME:   fig:firstgui01
[[./img/firstgui01.png]]

#+CAPTION: The constructor of our custom window: custom part
#+NAME:   fig:firstgui02
[[./img/firstgui02.png]]

#+CAPTION: our custom window's "measure" method
#+NAME:   fig:firstgui03
[[./img/firstgui03.png]]

#+CAPTION: footer of the program: what to do if it is called as a main program
#+NAME:   fig:firstgui04
[[./img/firstgui04.png]]

You cannot copy and paste the screenshots, however the complete program =p1.py=
can be downloaded from [[https://raw.githubusercontent.com/georgesk/course-affordable-science/master/prog/p1.py][a Github.com repository]].

Download the file (=p1.py=) and open it in a good editor to check its content. It
should work easily. For example, you can launch it by typing =python3 p1.py= and
hitting the Enter key, provided the default directory of the Terminal contains
=p1.py=.

Don't be afraid by this program! Obviously, seventy lines in a language which
you do not master currently can be an issue, but they are less an issue if you
consider that you can freely copy this program source, and that you become
really productive, just by modifying small details inside its structure. For
example, take a look at lines 56 -68: they are there like a placeholder, for
some useful program which you want to write. Plotting a function with random
values is quite a nonsense, but it will become far from a nonsense if you
replace those lines by a program to plot captured physical measurements.
*** Introducing some "meat" to replace nonsenses of the first program
The two subsequent programs will show you how to make some sense with the
previous program, by wisely replacing  some of its structure.

You can download [[https://raw.githubusercontent.com/georgesk/course-affordable-science/master/prog/p2.py][here]] the second program, named =p2.py=. The modified parts are:
1. the program's header, to include one more module
2. the =__init__= constructor, which initializes the expEYES Junior box
3. the =measure= method, which captures physical data thanks to the box, and plots
   them
*** Details of the first modification
**** modifications of the header part
The line  =import expeyes.eyesj as ej= allows us to control the expEYES Junior
measurement box from Python.
**** modifications of the constructor
The single line =self.p = ej.open()= attaches expEYES' driver object to the main
window.
**** modifications of the =measure= method
Only two lines are used: =t,v = self.p.capture(1,1000,200)= to request a thousand
voltage measurements, and =self.curve.setData(t,v,len(t))= to plot them.

The conclusion is: that *four lines of code* are sufficient to turn
a general-purpose GUI program into a usable scientific tool.
*** A few more code, to deal with real life problems and exceptions
The program =p2.py= works very well, with one exception: when no exPEYES Junior
box is connected to the computer, nothing happens as expected. If the program
was  launched from a command line in a Terminal, you may notice error messages
appearing there. But if the program is launched by some other method, chances
are that it will not work, and the reasons why it doesn't are not obvious for the
average user.

The designer of a program which touches physical realities must always keep
a thought about what can go wrong; the most usual issue is a false connection, or
no connection at all. Here we have an example: if the expEYES Junior box is not
connected, the application should provide an a strong enough feedback for
making the end user aware of the probable failure's reason.

Fortunately, Python offers a nice structure to deal with exceptions: the
construct =try: {some code which might trigger a failure} except: {someting to
do if the failure was triggered}=. You must write two blocks of code, the first
one is governed by the keyword =try:=, and it must raise an error (in the Python
sense) if anything goes wrong; the second one is governed by the keyword =except:=
and contain instructions to process if an error was raised in the previous
block.

#+NAME: prog:p3
[[https://raw.githubusercontent.com/georgesk/course-affordable-science/master/prog/p3.py][Here you can download]] a third program, which can deal with mistaken connection to
expEYES Junior (or any error reason which can fool the detection of the
hardware)

The differences between programs =p2.py= and =p3.py= are few:
- In the =try:= clause, :: the line =self.p = ej.open()= is now embeded in the =try:=
  block. A condition is tested just after this line: =assert(self.p.fd)= is an
  affirmation that the driver has a working file descriptor; unless this
  descriptor exists, a Python error is raised (you would see it if you write the
  same program line without the =try:= block); if this descriptor exists, the next
  lines change the title of the Main Window. In most cases, this title will become
  "=expEYES Junior found on port /dev/ttyACM0="
- In the =except:= clause, :: there are two lines of code, to manage the exception.
  The first one assigns the
  Main Window's title to "=ERROR: expEYES Junior NOT FOUND!=". The second one
  disables the button "=Measure=", since this button should not be used to
  make measurements.
*** Exercises: improve our first program
Here are some exercise propositions, which can make you more fluent with GUI
programming. Some are modifications touching just the user interface's design,
others touching the way captures are done, or are implementing additional features.
1. Change the user interface file, replace the label "Measure" by some other
   label, like "Launch a capture", for example
2. Add a button to save data into a file named "data.csv"; verify that this file
   can be readily opened by other programs like LibreOffice Calc.
3. Add a text input allowing end users to choose another file name
4. Change the capture instruction, in order to get a thousand voltage values,
   separated by time gaps of two milliseconds; the total capture time should be
   two seconds
5. Two seconds is quite a long time for our impatient students. Try to implement
   some way to provide a feedback message stating "Measuring voltage... please
   wait" from the click's time until the plot's update.
6. Add a text input to let users request a precise number of voltage samples, so
   they can ask for as many samples as they want inside a reasonable range.
7. Add text inputs to let users request other input channels than "A1", and also
   to change the sample frequency
8. Modify the widget used to request the measurement channel; replace it by
   a set of radio buttons, with labels "A1", "A2", "IN1", "IN2", "SEN", etc.
9. Change the set of radio buttons to a set of checkboxes, so users can select
   up to four of them, and up to four channels can be sampled simultaneously
10. Provide a second plot widget, which will display the power spectrum of the
    signal (i.e. amplitude vs. frequency) after a Fast Fourier Transform

Propositions of solutions for this set of exercises are published in the "[[https://github.com/georgesk/course-affordable-science/tree/master/sol/qtgui][repository]]".
* Writing the user interface for a new experiment
** Description of the new experiment
This experiment is about oscillations of a pendulum, and in most cases it can
already be managed by an application distributed with expEYES Junior, known as
"/Pendulum Waveform/". This application can be launched after a choice between
expEYES Junior's featured "/EXPERIMENTS/" (launch the oscilloscope application,
click on /EXPERIMENTS/, choose /Pendulum Waveform/).

However, the program which implements currently "/Pendulum Waveform/" misses
some features:
- it is built upon the graphic library /Tk/, which does not support easily
  right-to-left text writing in widgets
- it plots the oscillations of the pendulum in non-real time, i.e. the voltages
  samples are taken when the computer asks for them. In most cases it is not an
  issue, but it may become one when the frequency of the oscillation is
  rising. At higher frequencies, the task scheduler of the computer's operating
  system may prevent getting enough samples during one oscillation, which would
  lead to an odd-shaped curve.
*** Schematics
A massive object is hung under a spring. The top of the spring is tightly fixed,
and a vertical insulated wire is hung just below the massive object. The end of
this wire is unwrapped, so it acts as the cursor of a potentiometer. Eventually,
some light sheet of plastic or of metal is tightened to the massive object in
order to provide some friction while it moves in the air.

The potentiometer's body is a measuring cylinder filled with copper sulfide
($concentration = 0.01\, mol\cdot L^{-1}$), which bears two circular electrodes, made
with one turn of copper: one at the bottom of the cylinder, the other one near
the top of the copper sulfide solution. Both electrodes are connected through
insulated wires to a $4.5\, V$ battery. Whenever one connects the battery, she
should consider which electrode need to gain more copper, and connect the
negative end of the battery to this electrode (copper deposits on the cathode).

When some current flows between both electrodes, there are quite plane
equipotential surfaces, regularly spaced vertically between the electrodes. So
when the height of the vertical wire's tip movesup and down, its potential is
a linear function of its height. Figure [[fig:liquid_pot]] describes the experiment.

#+CAPTION: An oscillator made with a spring, and its liquid potentiometer
#+NAME: fig:liquid_pot
[[./img/liquid_pot.png]]
*** Features wanted for the program
ExpEYES Junior comes with a program named "Data Logger" which can be used to
monitor any signal captured by the measurement box. However, our experiment has
a few unique features which call for a more appropriated program:
- both hands of the person who does the experiment may be busy just at the
  moment when the capture of data should start, /i.e./ when the pendulum begins
  its first oscillation. Generally, the person pulls slowly the elastic pendulum
  far from its equilibrium point, takes care that the start position is well
  aligned with the axis of the main oscillation, and let it go suddenly. Then,
  the capture should begin within a fraction of a second.
- depending on the experiment, one may be interested by more than 1800
  measurements; 1800 measurements is the maximum number of voltage values which
  can be stored in the measurement box and sent as a response to a single
  query. From a didactic point of view, it can be also interesting to plot the
  signal's curve immediately, without waiting for the measurement series.
- the program can provide additional facilities, like fitting
  the results with a predefined model, and emphasizing some calculable results
  like a friction coefficient.
** Implementing new features
Here is a list of wanted features:
1. a button to wake up the program, so it will try to guess the start of the
   experiment
2. a button to stop the experiment at any time
3. buttons to save sets of data, quit, etc.
4. when the program is in "/alert mode/", it monitors the voltage input regularly,
   and triggers the begin of the capture when the voltage changes quicker that
   a predefined threshold
5. when the program is no longer in "/alert mode/", the user can launch fitting
   tools and compare the record to theoritical descriptions.
6. The curve of position vs. time is plotted inside a big frame, synchronously
   or asynchronously.
** Coding the new program
*** Designing the user interface
With the program =designer=, let us create something like the structure displaid
in figure [[fig:oscill_monitor]].

#+CAPTION: the user interface inside the application =designer=
#+NAME: fig:oscill_monitor
[[./img/oscill_monitor.png]]

The file is available from our [[https://github.com/georgesk/course-affordable-science/blob/master/oscill/oscill.ui][repository]], as =oscill.ui=. You can download
it, and make a few modifications, like
- changing some part of the layout,
- changing the tooltips associated with some widgets,
- adding some new widgets (it is better to keep existing widgets).
You can notice that every widget which must be connected to the main program was
named with an easy to remind identifier.

*** Exercise:
1. Modify the user interface in order to have all the control widgets stacked on
   its right. Save the new interface file with a new name. Figure [[fig:oscill_monitor1]]
   gives an outlook of a possible layout.
2. Modify the user interface to translate "manually" texts and tooltips to your
   language. Save it under a new name. /Please notice that this is not the
   recommended method to translate an applications user interface/. /There are
   dedicated tools to perform this job more efficiently/, /and to have it done by
   other people/.

#+CAPTION: Control widgets of the application are stacked on the right
#+NAME: fig:oscill_monitor1
[[./img/oscill_monitor1.png]]
*** Minimal structure of the main program
The main program must at least:
1. import necessary modules and the user interface module
2. define a custom class for the main window, which will be linked to the user
   interface
3. build the user interface upon initialization of the main window
4. connect signals managed by the widgets to methods of the main window
5. create the application object, instantiate the main window, and let it run.

This is done in the program =oscill1.py= which can be downloaded [[https://github.com/georgesk/course-affordable-science/blob/master/oscill/oscill1.py][from the
"repository"]]; figures [[fig:prog_oscill1_1]] to [[fig:prog_oscill1_5]] show how those
five parts of the minimal program are implemented.

#+CAPTION: importing modules and classes from modules
#+NAME: fig:prog_oscill1_1
[[./img/prog_oscill1_1.png]]

#+CAPTION: the new class for the main window
#+NAME: fig:prog_oscill1_2
[[./img/prog_oscill1_2.png]]

#+CAPTION: building the user interface
#+NAME: fig:prog_oscill1_3
[[./img/prog_oscill1_3.png]]

#+CAPTION: connecting signals to methods
#+NAME: fig:prog_oscill1_4
[[./img/prog_oscill1_4.png]]

#+CAPTION: making it run
#+NAME: fig:prog_oscill1_5
[[./img/prog_oscill1_5.png]]

This program can be run, it raises no error. However, it makes nothing useful for
the end-user so far. When you click buttons or trigger menu actions, a message
pops up: "Sorry, not implemented", except for the method =close= which is
inherited from the ancestor =QMainWindow= class.
*** Adding methods to toggle the way curves will be plotted
There will be two methods to plot the curves:
1. immediately, while the pendule is still oscillating
2. once, when the scheduled data have been recorded

To implement this, a new property, =self.isImmediate= is initialized to =True= in the
main window's constructor, and methods =immediate= and =final= are defined to change
its value; see figure [[fig:prog_oscill2_1]]. Please notice that the identifiers
=immediate= and =final= are no longer assigned to =notImplemented=.

#+CAPTION: managing the plotting mode
#+NAME: fig:prog_oscill2_1
[[./img/prog_oscill2_1.png]]

*** Implementing naively the capture of data and the plotting routine
In this non-definitive version, the method =wakeUp= begins to capture data as soon
as the button is clicked,and the flag =self.isImmediate= is disregarded: data are
captured first, and the plot is refreshed later.

Most code have been copied from the file =p3.py= studied [[prog:p3][previously]]. The
implementation is done in file =oscill2.py=, which can be downloaded from the
[[https://github.com/georgesk/course-affordable-science/blob/master/oscill/oscill2.py]["repository"]]. Figure [[fig:prog_oscill2_2]] shows the code of the naive version of
the method =wakeUp=.

#+CAPTION: implementation of the method =wakeUp=
#+NAME: fig:prog_oscill2_2
[[./img/prog_oscill2_2.png]]

When we try to launch the program =oscill2.py=, measurements are well done for
durations of a few seconds: one, two or three seconds are well managed, but when
the duration of measurements is four seconds or more, the box replies no longer
and some error messages are emitted. One must unplug and plug again the USB
cable to get a working system. The programmer's manual states that too short
durations are not possible (there must be at least 4 µs between successive
samples), but issues with counter override are not documented.

So, we shall estimate that when the duration of the experiment must be longer
than 3.5 s, the measurements must be done in "immediate" mode.
*** Less naive implementation for the plotting routine
This implementation can be found in the program =oscill3.py=, available from the
[[https://github.com/georgesk/course-affordable-science/blob/master/oscill/oscill3.py]["repository"]].
The duration is tested: if it is longer than 3.5 s, the "immediate" mode is
enforced, and a timer is initialized to measure the signal regularly. As the
computer does not work in real time, a timestamp must be made as soon as a new
value is read. If the duration is in the range from 0.5 to 3.5 s, the mode is selected by
taking in account radio buttons, and if the duration is shorter than 0.5 s, the
"final" mode is enforced. The most relevant elements of code are shown in figure
[[fig:prog_oscill2_3]].

#+CAPTION: the new =wakeUp()= method
#+NAME: fig:prog_oscill2_3
[[./img/prog_oscill2_3.png]]

Figures [[fig:prog_oscill2_4]] and [[fig:prog_oscill2_5]] show how the "=tick=" method
implements gathering voltage and time when the application gets a =timeout=
signal, every 50 milliseconds, and how this timer was created during the
construction of the main window.

#+CAPTION: implementation of =tick=
#+NAME: fig:prog_oscill2_4
[[./img/prog_oscill2_4.png]]

#+CAPTION: initializing the application's timer
#+NAME: fig:prog_oscill2_5
[[./img/prog_oscill2_5.png]]
*** Implementing the callback for the Stop button
When one clicks the /Stop/ button, she wants to interrupt an acquisition of
data. Interrupting this acquisition is not possible in "/final/" mode, but during
the measurement timespan in "/immediate/" mode, it can be allowed. Figure
[[fig:prog_oscill4_1]] shows the implementation of the =stop= callback method.

#+CAPTION: implementing the =stop= callback method
#+NAME: fig:prog_oscill4_1
[[./img/prog_oscill4_1.png]]

*** Implementing the callback for the Save button
This part is straightforward: relevant data are self.t and self.v, the callback
method opens a text file and writes formatted data into it. See figure
[[fig:prog_oscill4_2]].

#+CAPTION: implementing the =save= callback method
#+NAME: fig:prog_oscill4_2
[[./img/prog_oscill4_2.png]]
*** Implementing the wait for a fast enough slew rate
You remember that one of our concern was to make it easy for a user which has
both hands in the experiment to launch the measurements. One way to achieve it
is to begin measurements not when the "wake up" button is clicked, but later, when
the voltage begins to swing. Therefore a control widget is designed to choose
the desired slew rate threshold which will trigger the measurement series. This
widget is a slider, to select a threshold ranging from zero to some volts per
second. The precise value of the higher selectable slew rate depends on the
experiment's scheduled duration. The shorter it is, the higher the threshold
slew rate should be.

So, the "=textChanged=" signal of the duration edit line is connected to
a callback function which changes the axis scale, but also changes the slider's
displaid range.

#+CAPTION: the =durationChanged= callback method
#+NAME: fig:prog_oscill4_3
[[./img/prog_oscill4_3.png]]

Then, some modifications are applied to the =wakeUp= method: a few lines are
prepended just before the measurement routines, to call the =waitForThreshold=
method.

#+CAPTION: a few lines prepended before the measurement calls
#+NAME: fig:prog_oscill4_4
[[./img/prog_oscill4_4.png]]

#+CAPTION: the =waitForThreshold= method
#+NAME: fig:prog_oscill4_5
[[./img/prog_oscill4_5.png]]

The =waitForThreshold= method has a parameter named =timeOut=, which allows one to
specify the longest possible wait period.
*** The fit utility
Thanks to the library =expeyes.eyemayh=, fitting a signal against a damped
sinusoidal function is quite straightforward. The function =fit_dsine= does all
the job, in a few steps: first, it guesses the pseudo-frequency of the signal
thanks to a Fourier transform, then it calls a routine from the module
=pylab.optimize= to minimize the differences between the signal and a parametric
equation of a damped sinus. The parameters returned by the modelling routine
are fed back in a text field (the optimized model equation is displaid), and
three additional curves are plotted in color: the model, and both positive and
negative envelopes which encompass its values. Figures [[fig:prog_fit]] and
[[fig:shot_fit]] show the program's source and a screenshot of the curves.

#+CAPTION: source of the =fit= method
#+NAME: fig:prog_fit
[[./img/prog_fit.png]]

#+CAPTION: captured signal and its model
#+NAME: fig:shot_fit
[[./img/shot_fit.png]]
*** The two help methods
Most of the contextual help for the end user is defined during the design of the
user interface. The program =designer= allows you to attach a help string to every
widget, which will appear as tooltip popup when the mouse cursors hovers it
a few time. Other parts of the contextual help can be fed to the user via the
status bar, and this can be written also while designing the user interface.

Two additional help methods are provided, respectively for menu items "Help \rightarrow
About" and "Help \rightarrow Manual". Both raise a browser window, which is fed a web page
(respectively =license.html= and =oscillo4.html=). The first file is automatically
made on the fly, based on the =license= variable which the program defines (at
the begin of the code).

*** Access to the complete source code
Please visit the "[[https://github.com/georgesk/course-affordable-science/raw/master/oscill/oscill4.py][repository]]". The program is distributed under a GPL v3
license, hence you can copy it, modify and redistribute it, provided you comply
with a few rules:
- redistributed versions must be ruled by the same license;
- authors must be quoted;
- if somebody received some /binary/ version of the program, and asks you
  to provide her its source code, you must give access to it.

This source code can be easily modified, improved, extended, changed to manage
other experiments, etc. For a beginner, three hundred lines of code are a big
deal, but they are lighter than many other similar programs written with other
languages and libraries. Copying and pasting parts of this program can speed up
drastically the writing of other scientific programs.

For more experimented programmers, some parts of this code can be turned into
prototype =classes=, which can be derived later into various usable end-user
programs to control scientific experiments with expEYES. Exactly like the
=PyQt4= library allowed us to derive a special =class MyWindow= from the base =class
QtGui.QMainWindow=, one can design a class featuring many widgets and methods
reusable by various scientific programs, like the plot widget, the timer to
periodically measure some signal, the detection of a slew rate as
a synchronization tool, etc.

** Exercises
Here a a few exercises which can be used to rework the program =oscill4.py=, the
user interface =oscill4.ui=, the help file =oscill4.html=. To start any exercise,
you can make a copy of all those files. Some other files like as =Makefile= and
=oscill4.org= can also be of some help if you are using appropriate tools:
respectively the command [[https://www.gnu.org/software/make/][make]] and an integrated development environment
with emacs, org-mode, $\TeX live$.

1. Display a message in the status bar (=self.ui.statusBar=) just after one clicks
   on the /Wake up/ button, and remove the message when the measurements
   begin. The message can be "waiting for a signal variation ..."
2. Make the previous message more interactive: format it with the template "{}
   seconds left, waiting for a signal variation ..."; the time value at the
   begin of the message should be refreshed every second while the measurements
   have not yet begun. The initial time value is the =timeOut= which is
   a parameter of the =wakeForThreshold= method.
3. The upper limit of slew rate selectable with the threshold slider is a little
   too low for many applications, so the synchronization behavior can bee too
   picky, and one cannot easily start the experiment. Modify the way this number
   is computed, to make the application more usable.
4. The menu provides a =Save= item, but no =Load File=. Implement a /Load File/
   submenu, and make someting useful out of it.
5. Add a new submenu /Load recent file .../ and make something useful out of
   it. It should provide a keyboard shortcut, and a quick method to cycle
   between recently measured series.
6. Modify the =fit= method. The user should be given a choice, for example,
   between a pure sinus model (no friction), an exponentially damped sinus model
   (fluid friction), and why not, a linear damped sinus model (solid friction).
7. Improve the user manual : for example, add some theory considerations about
   the damped sinus mode and fluid friction. You can adapt some contents from
   [[https://en.wikipedia.org/wiki/Damping][Wikipedia]], do not forget to quote the original article and credit its authors
   if you do so.
8. Add some widget to comment the measured data, when they are well fitted with
   a damped sinus: say whether the oscillation is under-damped, critically
   damped, over-damped.
9. Modify the user interface, wisely add some funny colors.
10. Add a dialog to ask the user whether she wants to save data (only if
    necessary) when she closes the application.
